# To lazy to copy and paste code again
from owt import base64_encode, base64_decode
import requests, json

TARGET = "http://localhost:4244"
BLOCK_SIZE = 16

def get_token():
    r = requests.get(TARGET + "/api/token/create")
    return r.json()['value']['token']

def get_enc_body(token: str):
    token_split = token.split('.')
    return base64_decode(token_split[1].encode('utf-8'))

def get_iv(token: str):
    token_split = token.split('.')
    header = json.loads(base64_decode(token_split[0].encode('utf-8')))
    return base64_decode(header["iv"].encode('utf-8'))

def modify_byte(d: bytes, value: bytes, index: int):
    return d[:index] + value + d[index+1:]

def get_padding_length(token, enc_body):
    header_enc = token.split('.')[0]
    n_blocks = len(enc_body) // BLOCK_SIZE
    block = enc_body[BLOCK_SIZE*(n_blocks-2):BLOCK_SIZE*(n_blocks-1)]

    for i in range(BLOCK_SIZE):
        test_block = block
        test_block = modify_byte(test_block, b'\x10', i)
        test_enc_body = enc_body[:BLOCK_SIZE*(n_blocks-2)] + test_block + enc_body[BLOCK_SIZE*(n_blocks-1):]
        test_token = "{header}.{body}".format(header = header_enc, body = base64_encode(test_enc_body).decode('utf-8'))
        r = requests.post(TARGET + '/api/token/verify', json={"token":test_token})
        result = r.json()
        if result['value'] == 'Verification Failed: Invalid padding!':
            return BLOCK_SIZE-i

    raise Exception("Could not figure out the padding length!")

def leak_block(token, enc_body, b_index, pads, b_pt="", iv_block=False):
    if BLOCK_SIZE-pads-1 < 0:
        return b_pt
    header_enc = token.split('.')[0]
    block = enc_body[BLOCK_SIZE*(b_index-2):BLOCK_SIZE*(b_index-1)]
    
    for i in range(BLOCK_SIZE-pads, BLOCK_SIZE):
        block = modify_byte(block, bytes([block[i]^pads^(pads+1)]),i)

    orig_byte = block[BLOCK_SIZE-pads-1]
    for i in range(0, 1<<8):
        block = modify_byte(block, bytes([i]), BLOCK_SIZE-pads-1)
        test_enc_body = enc_body[:BLOCK_SIZE*(b_index-2)] + block + enc_body[BLOCK_SIZE*(b_index-1):]
        test_token = "{header}.{body}".format(header = header_enc, body = base64_encode(test_enc_body).decode('utf-8'))
        r = requests.post(TARGET + '/api/token/verify', json={"token":test_token})
        result = r.json()
        if not result['value'] == 'Verification Failed: Invalid padding!':
            found_char = chr(i ^ (pads + 1) ^ orig_byte)
            return leak_block(token, test_enc_body, b_index, pads+1, b_pt = found_char + b_pt)


def padding_oracle_attack(token, iv, enc_body, pads):
    pt = leak_block(token, enc_body, pads, pads)
    enc_body = enc_body[:BLOCK_SIZE*(pads-1)]
    print("decrypted block")
    for b_index in range(3, 0, -1):
        if b_index == 1:
            enc_body = iv + enc_body
            b_index = 2
        pt = leak_block(token, enc_body, b_index, 0) + pt
        print("decrypted block")
        enc_body = enc_body[:BLOCK_SIZE*(b_index-1)]

    return pt

def main():
    token = get_token()
    iv = get_iv(token)
    enc_body = get_enc_body(token)

    pads = get_padding_length(token, enc_body)
    print("padding length:", pads)
    flag_dict = padding_oracle_attack(token, iv, enc_body, pads)
    print("plaintext:", flag_dict)

if __name__ == "__main__":
    main()